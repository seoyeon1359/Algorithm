he?p =>heap O  help O  helpp X

\*p\* => help O papa O hello X 

?는 어떤 글자와 비교해도 일치

\*는 0글자 이상의 어떤 문자열에도 일치



이 문제를 어렵게 만드는 것은  *가 몇 글자에 대응되어야하는지를 미리 알 수 없다는 점 입니다.

단순하게는 * 다음에 출현하는 글자가 나올때까지 대응시킬 수 있습니다만 이래서는 

예를들어 \*bb\* 의 와일드같은 경우 babbbc를 해결할 수가 없다.

이럴때 우리가 할 수 있는 가장 쉬운 방법은 완전 탐색입니다.

---

주어진 패턴이 m개의 \*를 포함한다고 합시다. 이 패턴을 \*가 나타날때마다 쪼개면  이 패턴이 문자열에 대응되는지 확인하는 문제를 m+1조각으로 나눌수있습니다. 예를들어 

우리의 완전 탐색 함수는 이 문자열중 모두 몇글자가 첫번째조각에 대응될지를 찾아내기위해 모든 경우의 수를 다 시도해봅니다. 만약 첫번째조각에 세글자가 대응된다고 하면 나머지 문자열이 나머지 네개의 패턴조각들에 대응되는지 여부를 재귀호출로 파악할 수 있지요

물론 실제로 패턴을 직접 쪼개지 않고도 이를 구현할수있습니다. 와일드카드 w가 원문s에 대응되는지 여부를 반환하는 함수match(w,s)를 만들어 봅시다. w와 s를 앞에서부터 한 글자씩 대응해나가며, \*를 만나거나 둘 중 한 문자열이 끝날 때에 멈춘다. 

종료하는 경우의 수를 자세히 따지면

1. s[pos] 와 w[pos]가 대응되지 않는다. : 볼것도 없이 대응 실패
2. w끝에 도달했다: 패턴에 *이 하나도 없는 경우. 이 경우에 패턴과 문자열의 길이가 정확히 같아야만  패턴과 문자열이 대응된다고 할 수 있다.
3. s끝에 도달했다: 패턴은 남았지만 문자열이 이미 끝난 경우. 남은 패턴이 전부 \*로 구성되어있다면 두 문자열은 대응될 수 있다. 이 경우를 제외하고는 항상 답은 거짓
4. w[pos]가 *인 경우  : *가 몇 글자에 대응될지 모르기때문에 0글자부터 남은 문자열의 길이까지를 순회하며 모든 가능성을 검사한다. 이때 w의 pos+1이후를 w' 패턴으로 하고 s의 pos+skip 이후를 s'로 해서 match(w',s')로 재귀 호출 했을때 답이 하나라도 참이면 답은 참이 된다. 

<h3>와일드카드 문제를 해결하는 완전탐색 알고리즘</h3>

```c++
//와일드 카드 패턴 w가 문자열 s에 대응되는지 여부를 반환한다.
bool match(const string&w,const string&w)
{
    //w[pos]와 s[pos]를 맞춰나간다.
    int pos =0;
    while(pos<s.size() && pos<w.size()&&(w[pos]=='?'||w[pos]==s[pos]))++pos;
    //더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.
    //2.패턴끝에 도달해서 끝난경우: 문자열도 끝났어야 대응됨
    if(pos==w.size())
        return pos==s.size();
    //4.*를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀호출하면서 확인한다.
    if(w[pos]=='*')
        for(int skip=0; pos+skip<=s.size(); ++skip)
            if(match(w.substr(pos+1),s.substr(pos+skip)))
                return true;
    //이 외의 경우에는 모두 대응되지 않는다.
    return false;
    
}
```





<h3>중복되는 부분 문제</h3>

이 알고리즘은 일부 예제 입력 경우에는 너무 오랜 시간이 걸릴 수 있다는 문제가 있다. 완전 탐색은 각 \*에 대응되는 글자수의 모든 조합을 검사하는데, 문자열이 길고 \*이 많을 수록 이 경우의 수는 늘어난다. 만약 이 많은 경우의 수 중 답이 하나도 없다면 우리는 그 답들을 하나하나 다 만들기 전에는 절대 종료하지 않을것이다. 

패턴 **************a 와 원문 aaaaaaaaaab 같은 경우가 이런 입력의 좋은 예이다.패턴의 마지막 글자는 a이고 문자열의 마지막 글자는 b이니 아무리 용을써봐야 이 패턴과 문자열은 서로 대응될수없다. 하지만 완전탐색알고리즘은 이중 한가지 방법으로는 일치될지 모른다는 헛된 믿음을 가지고 a들을 *에 대응시키는 수많은 경우의 수를 하나하나 검사하고 있으니 답이 나올수가 없다.

만약 이 코드가 실행되는 과정에서 수행하는 계산의 대부분이 여러번 중복으로 이루어진다면 입력이 주어졌을때 답을 저장하는 캐시를 이용하여 프로그램을 훨씬 빠르게 할 수 있다.  그런데 과연 중복이 얼마나 일어날까? 중요한 단서는 입력으로 주어질 수 있는 w와 s의 종류는 제한되어 있다는 것이다. 재귀호출할때 우리는 항상 w와 s의 앞에서만 글자들을 떼내기 때문에 w와 s는 항상 입력에 주어진 패턴 W와 파일면 S의 접미사가 된다. 따라서 입력으로 주어질 수 있는 w와 s는 각각 최대 101개 밖에 없다. 이때 match()가 101X101=10201번이상 호출되었다면 비둘기 집의 원리에 따라 어떤 부분 문제가 반드시 여러 번 계산되고 있다는 뜻이지요.

메모제이션을 사용해 이 상황을 해결해보자. w는 항상 전체 패턴 W의 접미사이기 때문에 w의 길이가 결정되면 w또한 결정된다. 이 점을 이용하면 101x101크기의 배열에 모든 부분문제의 답을 저장할수있다.

더이상 문자열을 재귀호출의 인자로 넘기지 않고 두 문자열의 시작위치만을 넘긴다.

<h3>와일드카드 문제를 해결하는 동적계획법 알고리즘</h3>

```c++
//-1은 아직 답이 계산되지 않았음을 의미한다.
//1은 해당 입력들이 서로 대응됨을 의미한다.
//0은 해당 입력들이 서로 대응되지않음을 의미한다.
int cache[101][101];
//패턴과 문자열
string W,S;
//와일드카드 패턴 W[w..]가 문자열 S[s..]에 대응되는지 여부를 반환한다.
bool matchMemoized(int w, int s)
{
    //메모이제이션
    int &ret = cache[w][s];
    if(ret!=-1)return ret;
    //W[w]와 S[s]를 맞춰 나간다.
    while(s<S.size() && w<W.size() && (W[w]=='?'||w[w]==S[s])){
        ++w;
        ++s;
    }
    //더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.
    //2. 패턴 끝에 도달해서 끝난경우 문자열도 끝났어야함.
    if(w==W.size())return ret = (s==S.size());
    //4.*를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀호출하면서 확인한다.
    if(W[w]=='*')
        for(int skip=0; skip+s<=S.size(); ++skip)
            if(matchMemoized(w+1,s+skip))
                return ret=1;
    //3. 이 외의 경우에는 모두 대응되지 않는다.
    return ret=0;
    
}
```

